#!/usr/bin/env perl
#*****************************COPYRIGHT******************************
# (C) Crown copyright 2017 Met Office. All rights reserved.
#
# Use, duplication or disclosure of this code is subject to the restrictions
# as set forth in the licence. If no licence has been raised with this copy
# of the code, the use, duplication or disclosure of it is strictly
# prohibited. Permission to do so must first be obtained in writing from the
# Met Office Information Asset Owner at the following address:
#
# Met Office, FitzRoy Road, Exeter, Devon, EX1 3PB, United Kingdom
#*****************************COPYRIGHT******************************
#
# Description: Examine namcouple files and extract the names and types 
# of fields to be exchanged, writing them to a namelist so that 
# all our component codes can read these details and define
# transients in an appropriate and consistent order without 
# having to hard code field names and all the associated problems. 
# NOTE: The file thus produced does not have to be copied 
# from run to run in the case of CRUNS because it will be 
# regenerated from scratch at every submission - the payoff being   
# extra processing v complicating an already complicated 
# data file handling system. 
#
# This code relies on namcouple files being annotated to indicate
# the position of transient field name definitions. We expect:
# the namcouple line immediately prior to the first line of each 
# transient field definition (the $STRINGS section) to contain
# ## TRANSDEF: mmmg  nnnh  i  f  x ############################
#
# Where:
#    TRANSDEF: is just a string to identify appropriate lines.  
#    mmm is a 3 letter string indicating the sending component (e.g. ATM, OCN)
#    g is a 1 letter string indicating the grid cell type in the sending 
#              component (T, U or V)
#    nnn is a 3 letter string indicating the receiving component (e.g. OCN, ATM)
#    h is a 1 letter string indicating the grid cell type in the receiving 
#              component (T, U or V)
#    i is an integer indicating the exchange sequence number of the field.
#              e.g. if ocn_sst is the first field to be exchanged, then this 
#              would have i=1. If heatflux is the 25th field to be exchanged
#              it would have the value of 25. Index numbers need not 
#              be contiguous. E.g. if a particular field is not required, then 
#              it can simply be deactivated by making the index number negative,
#              thus avoiding the need to undertake wholesale alterations to 
#              namcouple files. 
#              Further, fields can appear in any physical order within a 
#              file. e.g. one could define a field with index 24, followed by 
#              a field with  with index 53, followed by a field with  with index
#              7. 
#              The index number must be unique (unless negative.)
#              Gaps are allowed in index ranges. E.g. you could legitimately
#              define fields with indexes 1, 2, 3, 4, 8, 9 10 ....  
#              without defining 5, 6 or 7. 
#    f is the field ID integer. This is an identifying integer which is used
#              by each component to identify what physical field this
#              quantity relates to and therefore to allow that field to be
#              identified and processed appropriately within the components.  
#    x is an optional flag to say whether 2nd order conservative regridding 
#              is to be used. If it is, and IFF we are using OASIS3-MCT 
#              then we must perform extra operations on the put side. 
#              to generate transient field gradients and include them 
#              in put operations. 
############################################################################

# Standard pragmas
use strict;
use warnings;

# cat all the namcouples into one file. 
# The order is not important, so a straight cat 
# should be good enough. 

# Note this needs to cater for pseudo parallel 
# as well as oasis3-mct (mono coupler process) 
system("cat namcouple* > namclist");

my $process = 0; 
my $begin = 0;
my $end = 0;
my $mapping_type = 1;
my $items_count = 0; 

my @types;
my @names_out;
my @names_in;
my @names;

my $line_field_count = 0;
my $transient_o2a = 0;
my $transient_a2o = 0;
my $transient_c2a = 0;
my $transient_a2c = 0;
my $k_dim = 0;   # Size of 3rd dimension



# Now read our combined namcouple file and extract details for each transient
# to a FORTRAN namelist file. Namcouple files must be annotated in the 
# appropriate way. 

open( F0, "< namclist" );
open( F1, "> translist_part2" );
while (<F0>) {
   
    my $line = $_;
    chomp $line;    
    
    $line =~ s/^\s+//;    #remove leading spaces
    $line =~ s/\s+$//;    #remove trailing spaces
    
    if ( $line =~ m/\$STRINGS/) {
       # We have reached the start of the transients section, set the
       # flag to indicate that we want to process the file from here onwards.
       $process = 1;
    }


    if ( $process == 1 ) {


      if ( $begin == 1 ) {
         @names = split( / +/, $line );
	 
         # Now we need to cater for multi-2D fields which may be defined
         # on a single line, delimited by ":"
         @names_out = split( /:/, $names[0] );
         @names_in = split( /:/, $names[1] );

         $line_field_count = @names_out;  # How many field names on this line?
                                     # We must assume names_in and names out
                                     # contain the same number of elements!
         $k_dim = $line_field_count;	 
	 
	 $mapping_type = 1; 
	 
	 $items_count = @types;
	 if ( $items_count > 6 ) {
	 
	    # If the first character if our extra item is a hash
	    # then it's just a comment in namcouple terms in which 
	    # case we ignore it and presume first order remapping
	    # or that we're using OASIS3. 
	    if ( substr($types[6],0,1) ne "#" ) {
	    
	       # If our extra item indicates 1st or 2nd order 
	       # remapping specifically, then that's fine.
               if (($types[6] eq "1")||($types[6] eq "2")) {
            
	          if ( $types[6] eq "2" ){
	          # This indicates that the field should use 2nd order terms. 
	            $mapping_type = 2; 
	          }

               } else {
	          # If our extra item is not a valid order or a comment 
		  # indicator then say something. It's a moot point 
		  # whether we should abort or not - but we assume
		  # that anything invalid is a typo and default to 
		  # first order.   
		  print "****************** WARNING ***********************\n";
	          print "OASIS_fields: INVALID mapping type: $types[6] \n"; 
		  print "for $names[0] : 1st order remapping is assumed! \n";
		  print "**************************************************\n"; 
	       }
	    }   
	 }   
	 
         # We need to get the number of vertical levels by seeing how many fields 
	 # are specified on the transient definition line. 2D fields are simply given
	 # a vertical level of 1. 
         print F1 " &TRANSFLD C_OUT=\'$types[2]\',C_IN=\'$types[3]\',
	                      N_OUT=\'$names_out[0]\',N_IN=\'$names_in[0]\',
			      I_NUMBER=$types[4],F_ID=$types[5],
			      MAP_TYPE=$mapping_type,
			      MAX_LEV=$k_dim/\n";

         # The assumption for multi-2D field definitions (i.e. 3D fields) is 
	 # that the unique index number of each item is actually the sequence 
	 # index number plus the level number.
	
         if ( $types[2] =~ m/JNR/ ) {
            # The source is Junior UM so this is chemistry to atmos field
            $transient_c2a++ ;
         }
           
         if ( $types[2] =~ m/OCN/ ) {
            # The source is ocean so this is an ocean to atmos field
            $transient_o2a++ ;
         }

         if ( $types[3] =~ m/JNR/ ) {
            # The target is Junior UM so this is an atmos to chemistry field
            $transient_a2c++ ;
         }
           
         if ( $types[3] =~ m/OCN/ ) {
            # The target is ocean so this is an atmos to ocean field
            $transient_a2o++ ;
         }

         # We've finished dealing with this field so reset our 
	 # processing indicator ready for any subsequent records
         $begin = 0;


      }
        
      if ( $line =~ m/TRANSDEF/) {
    
         # If we've found a line containing TRANSDEF
         # then it holds details about which components
         # and grids are involved in this exchange.
          
         @types = split( / +/, $line );
       
         # Ignore fields with a non positive sequence number
         if ( $types[4] >= 1) { 
            $begin = 1;
         }
      }
    }   
    
}    

close(F1);
close(F0);

# Create a namelist with the maximum number of fields in each of 
# our potential coupling categories. 
open( F1, "> translist" );

  print F1 "&TRANSCOUNT TRANSIENT_A2O_COUNT=$transient_a2o,TRANSIENT_O2A_COUNT=$transient_o2a,
             TRANSIENT_A2C_COUNT=$transient_a2c,TRANSIENT_C2A_COUNT=$transient_c2a/\n";

close(F1);

# 
# Now amalgamate the two namelists into one file. 
system("cat translist_part2 >> translist");


