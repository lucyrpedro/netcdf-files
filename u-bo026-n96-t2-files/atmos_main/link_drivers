#!/usr/bin/env python
'''
*****************************COPYRIGHT******************************
 (C) Crown copyright 2016 Met Office. All rights reserved.

 Use, duplication or disclosure of this code is subject to the restrictions
 as set forth in the licence. If no licence has been raised with this copy
 of the code, the use, duplication or disclosure of it is strictly
 prohibited. Permission to do so must first be obtained in writing from the
 Met Office Information Asset Owner at the following address:

 Met Office, FitzRoy Road, Exeter, Devon, EX1 3PB, United Kingdom
*****************************COPYRIGHT******************************
NAME
    link_drivers

DESCRIPTION
    Top level control to coordinate either single or multiple model drivers
    to run a given configuration
'''

#The from __future__ imports ensure compatibility between python2.7 and 3.x
from __future__ import absolute_import
import importlib
import sys
import os
import argparse
import error
import common

def _check_drivers(models):
    '''
    Takes in our space separated list of models, and ensure that a driver is
    present for the module
    '''
    sys.stdout.write('MODELS %s\n' % models)

    models = models.split(' ')
    for model in models:
        drivername = '%s_driver.py' % model
        if not os.path.isfile(drivername):
            sys.stderr.write('[FAIL] Can not find driver file for model %s.'
                             ' The driver file should be named %s\n' %
                             (model, drivername))
            sys.exit(error.MISSING_DRIVER_ERROR)
    return models

def _run_drivers(common_envars, mode):
    '''
    Run the driver modules, and return an instance of common.LoadEnvars
    containing environment variables for that module, and a string containing
    a launcher command. This somewhat convoluted method ensures this
    module doesn't have to be modified when adding a new model. The mode is
    either run_driver to run the model, or finalize to run the finalization
    routines.
    '''
    if mode not in ('run_driver', 'finalize'):
        sys.stderr.write('[FAIL] driver only has run_driver or finalize'
                         ' modes\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    models = _check_drivers(common_envars['models'])
    envinsts = [common_envars]
    launchcmds = []
    for model in models:
        # namespace dictionary for exec function
        driver_name = '%s_driver' % model
        driver_mod = importlib.import_module(driver_name)
        model_envars, model_launch_cmd = driver_mod.run_driver(common_envars,
                                                               mode)
        envinsts.append(model_envars)
        launchcmds.append(model_launch_cmd)
        del driver_mod
    return envinsts, launchcmds


def _setup_common():
    '''
    Load environment variables common to all models
    '''
    common_envars = common.LoadEnvar()
    if common_envars.load_envar('models') != 0:
        sys.stderr.write('[FAIL] Environment variable models containg a space'
                         ' separated list of all the components in this run'
                         ' is not present\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    if common_envars.load_envar('RUNID') != 0:
        sys.stderr.write('[FAIL] Environment variable RUNID is not specified\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    if common_envars.load_envar('DATAM') != 0:
        sys.stderr.write('[FAIL] Environment variable DATAM is not specified\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    if common_envars.load_envar('DATAW') != 0:
        sys.stderr.write('[FAIL] Environment variable DATAW is not specified\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    if common_envars.load_envar('ROSE_LAUNCHER') != 0:
        sys.stderr.write('[FAIL] Environment variable ROSE_LAUNCHER is not '
                         'specified\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    if common_envars.load_envar('CYLC_TASK_WORK_DIR') != 0:
        sys.stderr.write('[FAIL] Environment variable CYLC_TASK_WORK_DIR is '
                         'not specified\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    if common_envars.load_envar('CYLC_TASK_NAME') != 0:
        sys.stderr.write('[FAIL] Environment variable CYLC_TASK_NAME '
                         'is not set\n')
        sys.exit(error.MISSING_EVAR_ERROR)
    # Check to see if the automatic restart has been disabled. By default
    # DRIVERS_VERIFY_RST will be True, and will be automatically turned off
    # if the configuration can not support the verification because it runs in
    # integer or gregorian cycling mode.
    _ = common_envars.load_envar('DRIVERS_VERIFY_RST', 'True')
    # If available load cylc environment variables to allow for verification
    # of restarts for cycling suites
    _ = common_envars.load_envar('CYLC_CYCLING_MODE', 'unset')
    if common_envars['CYLC_CYCLING_MODE'] in ('360day', '365day', 'gregorian'):
        # This is a cycling suite using a calendar and as such it is possible
        # to verify the start dumps at the start of a cycle
        if common_envars.load_envar('CYLC_TASK_CYCLE_POINT') != 0:
            sys.stderr.write('[FAIL] Environment variable CYLC_TASK_CYCLE_POINT'
                             ' is not specified\n')
            sys.exit(error.MISSING_EVAR_ERROR)
    elif common_envars['CYLC_CYCLING_MODE'] == 'integer':
        sys.stdout.write('[INFO] Using an integer cycling mode, therefore '
                         'drivers are unable to verify restart files\n')
        common_envars['DRIVERS_VERIFY_RST'] = 'False'
    elif common_envars['CYLC_CYCLING_MODE'] == 'unset':
        common_envars['DRIVERS_VERIFY_RST'] = 'False'
    else:
        sys.stdout.write('[FAIL] Cycling mode %s not permitted. The '
                         ' environment variable CYLC_CYCLING_MODE must have '
                         ' one of the following values:\n'
                         '  360day\n  365day\n  greogrian\n  integer\n' %
                         common_envars['CYLC_CYCLING_MODE'])
        sys.exit(error.INVALID_EVAR_ERROR)
    return common_envars

def _export_envar_str(envinsts):
    '''
    Create a bash command to (re)export all the environment variables
    for all models
    '''
    envar_str = ''
    for inst in envinsts:
        for var, val in inst.env_vars.items():
	    # If there is a space in the environment variable string and
            # it isn't already in quotes, we need to place it in quotes.
            # Note some environment variables may be unset currently
            if val:
                if val[0] not in ('\'', '\"') and ' ' in val:
                    val = "'%s'" % val
            envar_str += 'export %s=%s; ' % (var, val)
    return envar_str[:-1]

def _export_cmd_str_XC40(launchcmds, common_envars):
    '''
    Create an aprun launch command for the coupled configuration on the
    XC40
    '''
    cmd = '%s ' % common_envars['ROSE_LAUNCHER']
    for launchcmd in launchcmds:
        if launchcmd != '':
            cmd += launchcmd+' : '
    sys.stdout.write('[LINK_DRIVERS] attempting to run with command: %s\n'
                     % cmd[:-3])
    return cmd[:-3]






if __name__ == '__main__':
    # Owing to the limitations of aprun and passing information between the
    # shell and the python drivers, prepare two command files, one containing
    # an aprun command to execute, the other containing a command allowing
    # environment variables to be exported

    try:
        assert sys.version_info >= (2, 7)
        sys.stdout.write('Using python version %i.%i\n' %
                         (sys.version_info[0], sys.version_info[1]))
    except AssertionError:
        sys.stderr.write('Python version must be 2.7 or later. Currently'
                         ' using %i.%i\n' % (sys.version_info[0],
                                             sys.version_info[1]))
        sys.exit(error.VERSION_ERROR)

    parser = argparse.ArgumentParser()
    parser.add_argument("--run", help="run the coupled model",
                        action="store_true")
    parser.add_argument("--finalize", help="run the model finalize routines",
                        action="store_true")
    args = parser.parse_args()
    if args.run and args.finalize:
        sys.stderr.write('[FAIL] the run and finalize options are mutually'
                         ' exclusive')
        sys.exit(error.INVALID_DRIVER_ARG_ERROR)
    if args.run:
        mode = 'run_driver'
        # Setup the environment variables required to all drivers
        common_envars = _setup_common()

        # Create two lists by looping through all the required driver files:
        #    1. envinsts is a list of common.LoadEnvar() instances, each
        #      instance containing environment variables for a given driver
        #    2. launchcmds is a list of strings, containing options for each
        #      model to be passed to the parallel launcher on the system.
        envinsts, launchcmds = _run_drivers(common_envars, mode)

        # Create a string containing the export command and a list of
        # environment variable definitions that can be run by the shell
        envar_str = _export_envar_str(envinsts)

        # Create the aprun command
        cmd_str = _export_cmd_str_XC40(launchcmds, common_envars)

        # Write the export commands for common and model specific environment
        # variables (envar_str) into the file driver_envar
        envar_file = common.open_text_file('driver_envar', 'w')
        envar_file.write(envar_str)
        envar_file.close()

        # Write the model launch commands (cmd_str) into file driver_cmd
        cmd_file = common.open_text_file('driver_cmd', 'w')
        cmd_file.write(cmd_str)
        cmd_file.close()
    elif args.finalize:
        mode = 'finalize'
        common_envars = _setup_common()
        _, _ = _run_drivers(common_envars, mode)
